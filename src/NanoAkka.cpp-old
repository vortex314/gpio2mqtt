#include "NanoAkka.h"

#include <mqueue.h>
#include <stdint.h>

uint64_t asNanoSeconds(struct timespec& ts) {
  return ts.tv_sec * (uint64_t)1000000000L + ts.tv_nsec;
}

struct timespec asTimespec(uint64_t t) {
  struct timespec ts;
  ts = {(time_t)(t / 1000000000UL), (time_t)(t % 1000000000UL)};
  return ts;
}

struct timespec sumTimespec(struct timespec& t1, struct timespec& t2) {
  struct timespec ts = asTimespec(asNanoSeconds(t1) + asNanoSeconds(t2));
  INFO(" %u:%u + %u:%u = %u:%u ", t1.tv_sec, t1.tv_nsec, t2.tv_sec, t2.tv_nsec,
       ts.tv_sec, ts.tv_nsec);
  return ts;
}

NanoStats stats;
/*
 _____ _                        _
|_   _| |__  _ __ ___  __ _  __| |
  | | | '_ \| '__/ _ \/ _` |/ _` |
  | | | | | | | |  __/ (_| | (_| |
  |_| |_| |_|_|  \___|\__,_|\__,_|
*/
int Thread::_id = 0;

void Thread::createQueue() {
  struct mq_attr attr;

  /* initialize the queue attributes */
  attr.mq_flags = 0;
  attr.mq_maxmsg = 10;
  attr.mq_msgsize = sizeof(Invoker*);
  attr.mq_curmsgs = 0;

  /* create the message queue */
  _workQueue = mq_open("/nanoAkka", O_CREAT | O_RDWR, 0644, &attr);
  if (_workQueue == -1)
    WARN("Queue creation failed %d %s ", errno, strerror(errno));
}

void SetThreadName(std::thread* thread, const char* threadName) {
  auto handle = thread->native_handle();
  pthread_setname_np(handle, threadName);
}

void Thread::start() {
  INFO("");
  std::thread thr = std::thread([=]() { run(); });
  SetThreadName(&thr, _name.c_str());
}

int Thread::enqueue(Invoker* invoker) {
  INFO("Thread '%s' >>> '%lX", _name.c_str(), invoker);
  if (_workQueue)
    if (mq_send(_workQueue, (const char*)&invoker, sizeof(Invoker*), 0) == -1) {
      stats.threadQueueOverflow++;
      WARN("Thread '%s' queue overflow [%X]", _name.c_str(), invoker);
      return ENOBUFS;
    }
  return 0;
};
int Thread::enqueueFromIsr(Invoker* invoker) { return enqueue(invoker); };

void Thread::run() {
  INFO("Thread '%s' started ", _name.c_str());
  uint32_t noWaits = 0;
  while (true) {
    uint64_t now = Sys::millis();
    uint64_t expTime = now + 5000;
    TimerSource* expiredTimer = 0;
    // find next expired timer if any within 5 sec
    for (auto timer : _timers) {
      if (timer->expireTime() < expTime) {
        expTime = timer->expireTime();
        expiredTimer = timer;
      }
    }
    int32_t waitTime =
        (expTime - now);  // ESP_OPEN_RTOS seems to double sleep time ?

    //		INFO(" waitTime : %d ",waitTime);
    if (noWaits % 1000 == 999)
      WARN(" noWaits : %d in thread %s waitTime %d ", noWaits, _name.c_str(),
           waitTime);
    if (waitTime > 0) {
      Invoker* prq = 0;
      if (waitTime == 0) noWaits++;
      unsigned int priority = 0;
      uint32_t seconds = waitTime / 1000;
      uint32_t nanoSeconds = (waitTime - (seconds * 1000)) * 1000000;
      struct timespec delta = {seconds, nanoSeconds};
      struct timespec now;
      clock_gettime(CLOCK_REALTIME, &now);
      now.tv_nsec += delta.tv_nsec;
      now.tv_sec += delta.tv_sec;
      struct timespec abs_time = sumTimespec(now, delta);
      INFO(" wait queue %u", waitTime);
      int rc = mq_timedreceive(_workQueue, (char*)&prq, sizeof(Invoker*),
                               &priority, &abs_time);
      if (rc == sizeof(Invoker*)) {
        INFO(" got message %d on queue %lX", rc, prq);
        uint64_t start = Sys::millis();
        prq->invoke();
        INFO(" returned invoke");
        uint32_t delta = Sys::millis() - start;
        if (delta > 50)
          WARN("Invoker [%X] slow %d msec invoker on thread '%s'.", prq, delta,
               _name.c_str());
      } else if (rc == -1 && errno == ETIMEDOUT) {
        noWaits++;
        if (expiredTimer) {
          if (-waitTime > 100)
            INFO("Timer[%X] already expired by %u msec on thread '%s'.",
                 expiredTimer, -waitTime, _name.c_str());
          uint64_t start = Sys::millis();
          expiredTimer->request();
          uint32_t deltaExec = Sys::millis() - start;
          if (deltaExec > 50)
            WARN("Timer [%X] request slow %d msec on thread '%s'", expiredTimer,
                 deltaExec, _name.c_str());
        }
      } else {
        noWaits = 0;
      }
    }
  }
}
